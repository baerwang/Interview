# 什么是Singleton

- Singleton：在Java中即指单例设计模式，它是软件开发中最常用的设计模式之一。
- 单：唯一
- 例：实例
- 单例设计模式，即某个类在整个系统中只能有一个实例的对象可被获取和使用的代码模式。
- 例如：代表JVM运行环境的Runtime类

## 要点

1. 是某个类只能有一个实例

   构造器私有化

2. 是它必须自行创建整个实例

   含有一个该类的静态变量来保存整个唯一的实例

3. 是它必须自行向整个系统提供整个实例

   对外提供获取该实例对象的方式

   ​	1.直接暴露 2.用静态变量的get方法获取

## 几种常见的形式

- 饿汉式：直接创建对象，不存在线程安全问题
  - 直接实例化饿汉式(简洁直观)
  - 枚举式(最简洁)
  - 静态代码块饿汉式(合适复杂实例化)
- 懒汉式：延迟创建对象
  - 线程不安全(适用于单线程)
  - 线程安全(适用于多线程)
  - 静态内部类形式(适用于多线程)

# MySQL锁的介绍-悲观和乐观锁

> 悲观锁

​	概念：悲观锁和数据加锁持有一种悲观的态度。因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他锁(for update)，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）	

​	实现：在查询的时候，将查询语句加入一个行锁，和更新库存的语句互斥，保证在查询库存时库存不被修改。

​	使用场景：比较合适写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

​	特点：悲观随的特点是先获取锁，再进行业务操作，即"悲观"的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说"一锁二查三更新"指的是悲观锁。

> 乐观锁

​	概念：对加锁持有一种乐观的态度，即先进行业务操作，不到最后一步不进行加锁，"乐观"的认为加锁一定会成功，在最后一步更新数据的时候再进行加锁。	

​	实现：在查询的时候，加入一个版本字段，每次更新同时查询和更新版本的字段，如果版本字段发生变化，sql语句不会执行成功。

​	使用场景：比较合适读取操作比较频繁的场景，如果出现大量的写入操作，数据发生的冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

​	特点：乐观锁的特点先进性业务操作，不到万不得已不去拿锁。即"乐观"的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿下锁。

​	**读取频繁使用乐观锁，写入频繁使用悲观锁。乐观锁不能解决脏读的问题。**

# HashMap的工作原理

​	HashMap是一个k-v形式存储的元素，HashMap需要一个hash的函数，它使用HashCode和equals的方法来向集合添加和检索元素，当调用put()方法的时候，hashmap会计算key的hash的值，然后把键值对存储在集合中合适的索引上，如果key相同，value会被更新成新值。

# HashCode()和equals()的方法重要体现在什么地方

​	Java中的HashMap会使用hashCode()和equals()方法来确定键值对的索引，当根据键值的时候会用到这个两个方法，如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此会被集合认为是相等的。而且这两个方法也用来发现重复的元素。

# HashMap和HashTable有什么区别？

> HashMap和HashTable都实现了Map接口，因此很多特性非常相似。但是，他们有以下的不同点：

​	HashMap是HashTable的轻量级实现(非线程安全的实现)，他们都完成了Map的接口，主要区别在于HashMap允许k-v为null，由于非线程安全，在只有一个线程访问的情况下，效率要高于HashTable。

​	HashMap允许将null作为一个entry的key或者value，而HashTable不允许。

​	HashMap把HashTable的contains方法去掉了，改成了containsvalue和containsKey。因为contains方法容易让人引起误解。

​	HashTable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。

​	最大的不同是，HashTable的方法是Synchronize的，而HashMap不是，在多个线程访问HashTable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供外同步。

​	HashTable和HashMap采用的是hash/rehash算法都大概一样，所以性能不会有很大的差异。

​	HashTable是线程安全的，是同步的，HashMap是线程序不安全的，不是同步的。更合适单线程环境，而HashTable合适用于多线程环境。

# HashSet和TreeSet有什么区别？

​	HashSet是由一个hash表来实现的，因此它的元素是无序的。add()，remove()，contains()。方法的时间复杂度是O(1)。

​	另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的事件复杂度是O(logn)。



# 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList?

> 下面列出了Array和ArrayList的不同点：

- Array可以包含基本类型和对象的类型，ArrayList只能包含对象类型。
- Array大小是固定的，ArrayList是大小动态变化的。
- ArrayList提供了更多的方法和特征，比如：addAll()，removeAll()，iterator()等等。
- 对于基本类型数据，集合使用自动装箱来减少编码的工作量。但是当处理固定大小的基本数据类型的时候，这种方式相对比较慢。

# ArrayList和Vector的区别

​	这两个类都实现了List接口(List接口继承了Collection接口)，他们都是有序集合，即存储在这两个集合中的元素的文字都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。

> ArrayLit与Vector的区别

1. 同步性：

   ​	Vector是线程安全的，也就是说事它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些，如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。

   对于Vector ，ArrayList，HashTable，HashMap，要记住线程安全的问题，记住Vector与HashTable是旧的，是java诞生就提供了，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。

2. 数据增长：

   ​	ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector的默认增长为原来的两倍，而ArrayList的增长策略在文档中没有明确规定(从源码看到的是增长原来的1.5倍)。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。

3. 总结

   ​	即Vector增长原来的一倍，ArrayList增加原来的0.5倍

#  ArrayList和LinkedList有什么区别？

> ArrayList和LinkedList都实现了接口，它们有以下的不同点

​	ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它前一个和后一个元素连接在一起，在这种情况下，查找某个元素的事件复杂度是0(n)。

​	相对于ArrayList，LinkedList的插入，删除，添加操作速度更快，因为当元素被添加到集合任意位置的时候，不需要想数组那样重新计算大小或者是更新索引。

​	LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

# List，Map，Set三个接口存取元素时，各有什么特点？

​	List与set具有相似性，他们都是单列元素的集合，所以他们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等(不是仅仅相同)的对象。

​	List表示有先后顺序的集合，不是按照那种年龄，大小，价格之类的排序。当我们多次调用add(Object obj)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候也可以插队，即调用add(int index,Object obj)，就可以指定当前对象在集合中存放的位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。

​	Map与List和Set不同，它是双列的集合，其中有put(k,v)方法，定义如下：put(Object key,Object value)，每次存储时，要存储一对k/v，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key所对应的value。另外也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合的Map.Entry对象的集合

​	List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素，内部排序。Map保存k-v值，v可多值。

​	HashSet是按照hashcode的值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储，例如："abc" - > 78，"def" - > 62，"xyz" - > 65 在hashSet中的存储顺序不是62,68,78而是通过hashcode的值进行存储。

# Collection 和 Collections的区别

​	Collection是集合类的上级接口，继承与它的接口主要有Set和List。

​	Collections是针对集合类的一个帮助类，它提供一系列静态方法实现对各种集合的搜索，排序，线程安全化等操作。

# Comparable和Comparator接口是干什么的？列出它们的区别？

​	Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以给两个对象排序。具体来说，它返回负数0，整数来表名已经存在的对象小于，等于，大于输入对象。

​	Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，整数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数野视一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

# Java集合类框架的最佳实践有哪些？

​	根据应用的需要正确选择要使用的集合的类型对性能非常重要，假如元素大小是固定的，而能事先知道，我们就应该用Array而不是ArrayList。

​	有些集合类允许指定初始容量。我们能够估计出存储的元素的数目，可以设置初始容量来避免重新计算hash值或者扩容。

# 什么是Java优先级队列(Priority Queue)？

​	PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器，最后，PriorityQueue不是线程安全的，入队和出队的时候复杂度是O(log(n))。

# Java中的垃圾回收有什么目的？什么时候进行垃圾回收？

​	垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。

# finalize()方法什么时候被调用？析构函数(finalization)目的是什么？

​	垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法，但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说finalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。

> finalize()究竟是做什么呢？

​	它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收期，所以一般情况下内存问题不用程序员担心。但有一种JNI(Java Natice Interface)调用 non--Java程序(C 或者 C++),finalize()的工作就是回收这部分的内存。

# Java实现线程有哪几种方式？

1. 继承Thread类实现多线程
2. 实现Runnable接口方式实现多线程
3. 使用ExecutorService，Callable，Future实现有返回结果的多线程

# 多线程同步有哪几种方法？

​	Synchronized关键字，Lock锁实现，分布式锁等。

# Runnable和Thread用哪个好？

​	Java不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他的类，也为了减少类之间的耦合性，Runnable会更好。

# Java中 notify 和 notifyAll 有什么区别？

​	notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

# 为什么wait/notify/notifyAll这些方法不再Thread类里面？

​	因为Java提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于**wait**，**notify**和**notifyAll**都是锁级别的操作，所以把他们定义在Object类中，因为锁属于对象。

# 为什么wait和notify方法要在同步块中调用？

​	主要是因为Java API强制要求这样做，如果你不这样做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。

# 什么是死锁？

​	死锁就是两个线程互相等待对象释放对象锁。

# 启动线程方法 start() 和 run()有什么区别？

​	只有调用了start()方法，才会出现多线程的特性，不同线程的run()方法里面代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。

# 多线程之间如何进行通信

​	wait/nofity

# 什么是线程池？

​	要执行的多线程交给线程池来处理，也连接池概念一样，通过维护一定数量的线程池来达到多个线程的复用。

# 线程池的好处

​	我们自动不用线程池的话，每个线程都要通过new Thread(xxRunnable).start()的方式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会熬尽系统的CPU和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。

# 什么是活锁，饥饿，无锁，死锁？

​	死锁，活锁，饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃就不能正常的执行下去了。

> 死锁

​	死锁是多线程中最差的一种情况，多个线程相互占用对象的资源的锁，而又相互等对象释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。