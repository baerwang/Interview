# Java 并发编程的艺术 - volatile



在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的"可见性"。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用适当的话，它比synchronized的使用和执行成本更低，因为它不会引起上下文的切换和调度。

1. volatile的定义与实现原理

   Java编程语言允许线程访问共享变量，是为了确保共享变量能够确保能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

   CPU的术语定义

   | 术语| 英文单词               | 术语描述                                                     |
   | ---------- | ---------------------- | ------------------------------------------------------------ |
   | 内存屏障   | memory barriers        | 是一组处理器指令，用于实现对内存操作的顺序限制               |
   | 缓冲行     | cache line             | 缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期 |
   | 原子操作   | atomic operations      | 不可中断的一个或一系列操作                                   |
   | 缓存行填充 | cache line fill        | 当处理器识别到从内存中读取操作是可缓存的，处理器读取整个缓冲行到适当的缓存（L1、L2、L3的或所有） |
   | 缓存命中   | cache hit              | 如果进行告诉缓存行填充操作的内存位置仍然是下次处理器访问的地址，处理器从缓存中读取操作数，而不是从内存读取 |
   | 写命中     | write hit              | 当处理器讲操作数写回到一个内存缓冲的区域时，它首先会检查这个缓存的地址是否在缓存行中，如果存在一个有效的缓存行，则处理器讲这个操作数写回缓存，而不是写回到内存，这个操作被称为写命中 |
   | 写缺失     | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |

   有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，Lock前缀的指令在多核处理器下会引发了两件事情。
   
   1. 将当前处理器缓存行的数据写回到系统内存。
   2. 这个写回内存的操作会使在其他CPU里缓存该内存地址的数据无效。
   
   为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1、L2或其他），但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器的缓存的值还是旧的，旧回是实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是不是过期了，当处理器发现自己存行对应的内存地址被修改，就会将当前处理器的缓存行设置称无效状态，当处理器对这个数据进行修改操作，会重新从系统内存中把数据读到处理器缓存里。
   
   volatile两条实现原则：
   
   1. **Lock前缀指令会引起处理器缓存回写到内存。**Lock前缀指令导致在行指令期间，声言处理器的Lock信号。在多处处理器环境中，Lock信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，Lock信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言Lock信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言Lock信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一性质机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
   2. **一个处理器的缓存回写到内存回导致其他处理器的缓存无效。**IA-32处理器和Intel 64处 理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致 性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统 内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的 缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理 器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理 器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。
   
   

